module memory_coordinator
version: "1.2.0"
use core_schema as core
use node_registry as reg

entity RamChunk
  properties:
    - tenant_id: string
    - node_id: string
    - chunk_id: uuid
    - capacity_mb: int
    - available_mb: int
    - usage: list[uuid] = []
    - locked: bool = false

flow allocate_ram
  inputs: tenant_id, node_id, required_mb, task_id
  outputs: chunk_id
  steps:
    - ensure exists reg.Node where tenant_id=tenant_id and node_id=node_id
    - let c = select RamChunk where node_id=node_id and available_mb >= required_mb and locked == false
    - if c is null then create RamChunk { tenant_id, node_id, chunk_id: uuid(), capacity_mb: required_mb, available_mb: required_mb }
      else update c set available_mb = c.available_mb - required_mb; push c.usage += task_id
    - emit span "ram.allocated" attrs { tenant_id, node_id, task_id, required_mb }
    - return c.chunk_id or new.chunk_id

flow release_ram
  inputs: tenant_id, node_id, chunk_id, mb, task_id
  steps:
    - let c = select RamChunk where chunk_id=chunk_id and node_id=node_id
    - update c set available_mb = min(capacity_mb, available_mb + mb); remove c.usage -= task_id
    - emit span "ram.released" attrs { tenant_id, node_id, task_id, mb }
