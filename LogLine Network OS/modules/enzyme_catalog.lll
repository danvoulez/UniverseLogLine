module enzyme_catalog
version: "1.0.0"
use core_schema as core

# Enzimas canônicas

flow apply(enzyme_id, params, payload)
  steps:
    - switch enzyme_id:
        - case "polymerase":   enzyme_polymerase(params, payload)
        - case "chaperone":    enzyme_chaperone(params, payload)
        - case "catalase":     enzyme_catalase(params, payload)
        - case "lorentz_bias": enzyme_lorentz_bias(params, payload)
        - default: no-op

# Duplica execução (hedging controlado)
flow enzyme_polymerase
  inputs: params, payload
  steps:
    - let boost = params.hedge_ms or 1500
    - patch core.Contract where contract_id=payload.contract_id set { hedging_ms = max(hedging_ms, boost) }

# Garante reserva/consistência de recursos
flow enzyme_chaperone
  inputs: params, payload
  steps:
    - if payload.state == "queued":
        set payload.requirements.ram_gb = ceil(payload.requirements.ram_gb * 1.10)

# Amortece incidentes (reduz severidade + reclassifica)
flow enzyme_catalase
  inputs: params, payload
  steps:
    - if payload.severity in [high, critical]:
        set payload.severity = high
        schedule incident_response.mitigate_incident in "3s" with { action: "reroute" }

# Introduz viés magnético de roteamento (usa módulo magnetic_field)
flow enzyme_lorentz_bias
  inputs: params, payload
  steps:
    - let bias = magnetic_field.compute_bias(payload.tenant_id, payload.candidate_nodes, payload.contract_id)
    - for c in bias: set c.network_score = max(1, c.network_score - c.bias_delta)
