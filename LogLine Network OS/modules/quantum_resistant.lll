module quantum_resistant
version: "1.0.0"

use id_orchestration as idm
use core_schema as core
use timeline_logger as tl

enum PQAlgo [dilithium, kyber, sphincs]

entity QuantumKey
  key: key_id (uuid)
  properties:
    - tenant_id: string
    - owner: idm.LogLineID
    - key_id: uuid
    - algorithm: PQAlgo
    - public_key: bytes
    - key_size: int
    - rotation_cron: string
    - created_at: core.datetime

flow upgrade_to_quantum_safe
  inputs: tenant_id, owner (idm.LogLineID), algorithm (PQAlgo)
  outputs: QuantumKey
  steps:
    - let kp = pqc_generate(algorithm)
    - let qk = create QuantumKey { tenant_id, owner, key_id: uuid(), algorithm, public_key: kp.pub, key_size: len(kp.pub), rotation_cron: "0 3 * * *", created_at: now() }
    - tl.log_event(tenant_id, "pqc.enabled", { owner: owner.id, algorithm })
    - return qk

flow ensure_pqc_keys
  inputs: tenant_id, ids (list[idm.LogLineID])
  steps:
    - for i in ids:
        if not exists QuantumKey where owner == i:
          upgrade_to_quantum_safe(tenant_id, i, dilithium)
