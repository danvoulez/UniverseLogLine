module consensus_engine
version: "1.1.0"

use core_schema as core
use core_ext as ext
use id_orchestration as idm
use timeline_logger as tl
use audit_wallet as aw
use zero_knowledge_auth as zk
use quantum_resistant as pqc

entity ValidatorSet
  key: set_id (uuid)
  properties:
    - tenant_id: string
    - set_id: uuid
    - validators: list[idm.LogLineID]    # ordem define prioridade de proposição
    - threshold: float = 0.6667
    - pqc_required: bool = true
    - zk_required: bool = false
    - created_at: core.datetime

entity ConsensusRound
  key: round_id (uuid)
  properties:
    - tenant_id: string
    - round_id: uuid
    - height: int
    - proposer: idm.LogLineID
    - validator_set: ValidatorSet
    - state_hash: ext.hash
    - signatures: map[idm.LogLineID, ext.signature]
    - finalized: bool = false
    - created_at: core.datetime

rule minimum_validators
  condition: length(ValidatorSet.validators) >= 3
  consequence: allow
  else: raise_error("need_at_least_3_validators")

flow byzantine_consensus
  inputs: tenant_id, state_proposal, set_id
  outputs: ConsensusRound
  steps:
    - let vset = select ValidatorSet where tenant_id=tenant_id and set_id=set_id
    - require vset not null
    - if vset.zk_required: zk.preflight_group_auth(tenant_id, vset.validators)
    - if vset.pqc_required: pqc.ensure_pqc_keys(tenant_id, vset.validators)
    - let h = ext.sha256(serialize(state_proposal))
    - let proposer = vset.validators[ (now().epoch % length(vset.validators)) ]
    - let round = create ConsensusRound { tenant_id, round_id: uuid(), height: monotonic("consensus.height"), proposer, validator_set: vset, state_hash: h, created_at: now() }
    - broadcast_proposal(round, state_proposal)
    - let votes = collect_votes(round, vset.validators, h, deadline="3s")
    - verify_signatures(round, votes) -> ok
    - require ok else raise "invalid_signatures"
    - require (length(votes)/length(vset.validators)) >= vset.threshold else raise "insufficient_quorum"
    - update ConsensusRound set finalized = true where round_id = round.round_id
    - tl.log_event(tenant_id, "consensus.finalized", { round_id: round.round_id, height: round.height })
    - aw.issue_receipt(tenant_id, round.round_id, 0.00, "consensus")
    - return round

flow verify_signatures
  inputs: round (ConsensusRound), votes (map[idm.LogLineID, ext.signature])
  outputs: bool
  steps:
    - for (vid, sig) in votes:
        let pub = public_key_of(vid)
        let ok = ext.ed25519_verify(round.state_hash, sig, pub)
        require ok else return false
    - update ConsensusRound set signatures = votes where round_id = round.round_id
    - return true
