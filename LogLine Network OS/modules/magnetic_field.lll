module magnetic_field
version: "1.0.0"

entity MagneticDomain
  key: domain_id (string)
  properties:
    - tenant_id: string
    - domain_id: string         # ex: "loja", "casa", "railway"
    - origin: vec3f             # (x,y,z) metros
    - coil_max_mT: mTesla = 20  # saturação segura
    - damping: float = 0.6      # amortecimento do viés

entity Magnet
  key: magnet_id (uuid)
  properties:
    - tenant_id: string
    - domain_id: string
    - magnet_id: uuid
    - position: vec3f
    - direction: vec3f          # vetor unitário
    - strength_mT: mTesla
    - last_set: datetime

entity NodePlacement
  key: node_id (string)
  properties:
    - tenant_id: string
    - node_id: string
    - domain_id: string
    - coord: vec3f              # posição do nó
    - orientation: vec3f        # orientação do chassi (para EMI)

# Calcula viés magnético para cada candidato (menor é melhor)
flow compute_bias
  inputs: tenant_id, candidate_nodes, contract_id
  outputs: list[{node_id, bias_delta}]
  steps:
    - let dom = select MagneticDomain where tenant_id=tenant_id limit 1
    - if dom is null then return []
    - let mags = select Magnet where tenant_id=tenant_id and domain_id=dom.domain_id
    - let places = select NodePlacement where tenant_id=tenant_id
    - let out = []
    - for n in candidate_nodes:
        let p = find places where node_id==n.node_id
        let influence = 0.0
        for m in mags:
          influence += dot(m.direction, normalize(p.coord - m.position)) * (m.strength_mT / (1.0 + dist(p.coord, m.position)))
        let bias = clamp(influence * dom.damping, -3.0, 3.0)   # converter para delta discreto
        append out += { node_id: n.node_id, bias_delta: round(-bias) }
    - return out

policy safe_field_limits
  when any(Magnet.strength_mT) > MagneticDomain.coil_max_mT
  action raise_error("coil_overdrive")
